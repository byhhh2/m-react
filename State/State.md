# State

- 컴포넌트와 관련된 일부 데이터가 시간에 따라 변경될 경우 state가 필요하다.
- 컴포넌트에 의해 완전히 제어된다.

## ✨ `state` vs `props`

| State                                     | Props                              |
| ----------------------------------------- | ---------------------------------- |
| 컴포넌트에서 관리된다.                    | 부모 컴포넌트로부터 전달받는다.    |
| 변경할 수 있다.                           | 컴포넌트는 props를 변경할 수 없다. |
| 소유하는 컴포넌트는 하나만 존재해야 한다. |                                    |

## ✨ state 사용 규칙

- 서로 다른 두 컴포넌트의 state를 동기화 하려하지 말아야한다. 공통 상태를 두 컴포넌트의 공통 조상으로 끌어올리고, props로 전달하자.
- 직접 state를 수정하지 마라
  - 직접 지정할 수 있는 공간은 constructor뿐 (in 클래스형 컴포넌트)
  - 대신 `setState`를 사용할 것
- state 업데이트는 비동기적일 수 있다.
  - 성능을 위해 여러 setState 호출을 단일 업데이트로 한꺼번에 처리할 수 있다.
  - state가 비동기적으로 업데이트 될 수 있기 때문에 다음 state를 계산할 때 해당값에 의존해서는 안된다.
- state 업데이트는 병합된다.
  - 변수들을 독립적으로 업데이트 할 수 있다.
  - 병합은 얕게 이루어진다.
    - `this.setState({comments})`는 `this.state.posts`에 영향을 주진 않지만 `this.state.comments`는 완전히 대체된다.
- 데이터는 아래로 흐른다. (핵심)
  - 하향식 (top-down) 또는 단방향식 데이터 흐름이라고 부른다.
  - 부모나 자식 컴포넌트는 어떤 특정 컴포넌트가 상태를 가지는지 아닌지, 함수인지, 클래스인지 관심을 가질 필요가 없다.
  - state는 로컬 또는 캡슐화라고 불린다.
    - 소유하고 설정한 컴포넌트 이외에는 어떤 컴포넌트든 접근 할 수 없다.
- state는 항상 특정 컴포넌트가 소유하고 있다.
  - 그 state는 자신의 아래에 있는 컴포넌트에만 영향을 미친다.
  - state는 물의 근원, props는 폭포

## ✨ state란? (= 테코톡 😎)

### react에서 state란?

- 바닐라 자바스크립트를 사용했던 시절.. 데이터 변경이 있는 웹 페이지를 만들기 위해서는 데이터 변경이 일어날 때마다 DOM에 접근하여 직접 수정해주었다. 이유는 데이터가 변경된 만큼 사용자가 보는 화면도 변경되어야 하기 때문이다.
- react를 사용하는 지금.. state를 JSX안에 넣어주고 있다. 여기서 데이터 바인딩이라는 단어를 알아야 한다. 바닐라 자바스크립트로 개발했을 때에는 여러개의 자바스크립트 객체와 화면에 있는 데이터를 직접 일치 시켜주어야 했다. 하지만 리액트가 데이터 바인딩을 대신 해주기 때문에 그럴 필요가 없어졌다. 데이터 바인딩이란 쉽게 말해 데이터를 뷰에 쏙쏙 넣어주는 작업을 뜻한다. 리액트는 단방향 데이터 바인딩을 지원하는데, 이는 데이터와 템플릿을 결합하여 화면을 생성한다.
- 우리는 변경되는 데이터를 위해 리액트에서 지원하는 state를 사용할 수 있다. state를 사용하면 자동으로 관련된 화면을 리렌더링 해줄 수 있다.
- react에서는 하향식으로 데이터가 흐른다. 컴포넌트는 자신의 state를 자식 컴포넌트에게 props로 전달해준다. 자식 컴포넌트를 설계할 때 자식은 props가 누구로부터, 어떤 방식으로 전달되는지 전혀 알 필요가 없다. 이 때문에 state는 종종 캡슐화라고 불린다. props가 폭포라면 state는 물의 근원이라고 할 수 있다. state는 state를 가지고 있는 해당 컴포넌트에서 관리가 된다. state를 자식 컴포넌트에게 넘겨주면 props가 되고 props는 읽기 전용 데이터로써 immutable하다.

### 클래스형 컴포넌트의 `setState`

- class형 컴포넌트에서 state를 갱신하기 위해 `setState`를 사용한다. 이는 `setState`를 통해 state를 변경했을 때에만 화면이 리렌더링되기 때문이다.
- 이는 react의 life cycle 흐름을 살펴보면 된다. 화면이 업데이트 되기 위해서는 `render()`함수가 실행되어야 한다. `setState`는 컴포넌트의 update 프로세스를 trigger한다. 즉, `setState`를 사용해서 state를 변경해야 react가 state가 변경되었음을 감지할 수 있다. update 프로세스 life cycle 중 `shouldComponentUpdate`는 state가 변경되었는지 비교연산을 진행한다. 그런데 `shouldComponentUpdate`는 PureComponent를 사용하지 않았다면 기본값으로 true를 반환하기 때문에 `setState`를 사용하면 항상 re-render가 된다. 즉, state를 직접 변경하게 되면 state가 변경되었을 수는 있지만, `render()` 함수가 실행되지 않기 때문에 보이는 화면이 업데이트 되지 않는다.
- state가 업데이트 되고 사용자가 보는 화면이 업데이트 될 때까지는 이러한 순서(`setState`를 통해 state 변경 -> state가 변경됨을 감지 -> 화면을 re-render)를 따른다.
- state를 연속적으로 변경하면 변경이 안될 수 있다. 이유는 react는 컴포넌트가 re-render될때 까지 state를 갱신하지 않기 때문이다.
- 사실 `setState`는 state를 바로 갱신하지 않는다. `setState`는 state를 변경하라는 즉각적인 명령이 아닌 요청이며, `setState`는 state 변경사항을 대기열에 집어넣고, 컴포넌트에게 갱신된 state를 사용하기 위해 다시 렌더링 해야한다고 알리는 역할일 뿐이다. 즉, setState는 비동기적으로 작동한다. (이런 이유로 연속적으로 `setState`를 호출해도 state가 변경되지 않았던 것이다. `this.state`는 렌더링 이후의 화면에 보이는 값을 가르킨다.)
- `setState`에 updator함수를 넘겨주면 `setState`가 비동기적으로 동작하는 것 역시 동일하지만 state가 갱신된 이후에 다시 업데이트 해주는 것이 보장된다. updator함수의 첫번째 매개변수는 최신 state임을 보장해주고, 두번째 매개변수는 최신 props인 것을 보장해준다.
- `setState`는 왜 비동기적으로 작동할까? 연속적으로 state를 변경하고 변경 횟수만큼 re-render를 진행한다면 이는 성능저하를 가져온다. `setState`가 동기로 동작한다고 가정해보자. 특정 이벤트가 발생했을 때 부모 컴포넌트, 자식 컴포넌트 둘 다 `setState`를 실행한다고 생각해보자. 자식 컴포넌트는 `setState`가 발생하자마자 re-render된다. 그리고 부모 컴포넌트도 `setState`가 발생하자마자 re-render된다. 부모 컴포넌트가 re-render됨으로써 자식 컴포넌트는 다시 한번 re-render되어야 한다. 여기서 자식 컴포넌트는 불필요하게 두번 렌더링이 되어야 한다. 즉, `setState`가 동기적으로 동작한다면 n번 변경만큼 n회 렌더링이 되기 때문에 성능저하를 가져올 수 있다.
- react는 인지성능 향상을 위해 `setState`의 실행을 지연시키고 여러 컴포넌트를 한번에 갱신한다. 여기서 배치처리라는 말을 알아야 하는데 배치처리는 데이터를 실시간으로 처리하지 않고 종합하여 처리하는 것을 일컫는다. react는 `setState`를 연속적으로 호출하면 `setState`를 모아서 배치처리한 후 렌더링을 발생시킨다. 이런 이유로 `setState`를 호출하자마자 state에 접근하는 것은 위험할 수 있다.
- 정리하자면 `setState`는 state를 바로 갱신하지 않을 수 있으므로 `setState`에 updator함수를 넘겨주거나, 생명주기 함수인 `componentDidUpdate`를 활용해야한다. 이들을 활용할 경우 갱신이 적용된 뒤에 실행되는 것이 보장된다.

> ### 언제 setState가 비동기적인가요?
>
> - 이벤트 핸들러 내에서 비동기적!
>   - 부모와 자식이 모두 click이벤트에서 setState를 호출한다면 자식은 두번 렌더링 되지 않는다.
>   - 대신 브라우저 이벤트가 끝날 시점에 state를 일괄적으로 업데이트 한다. (성능 향상을 위해)
>   - 모든 컴포넌트가 자신의 이벤트 핸들러에서 setState를 호출할 때까지 리렌더링을 하지않고 내부적으로 기다리고 있다. (불필요한 렌더링 방지)
> - 왜 리렌더링 대신 즉시 state를 업데이트하지 않느가?
>   - props와 state사이에 일관성을 해칠 수 있다. (디버깅하기 힘들다)
>   - 현재 작업 중인 새로운 기능들을 구현하기 힘들게 만든다.

### 함수형 컴포넌트의 `useState`

- 함수형 컴포넌트는 가끔 stateless 컴포넌트로 불린다. state가 없다면 변화하는 데이터를 어떻게 페이지에 넣어줄까?
- 함수형 컴포넌트에서 state를 사용하지 못하는 이유는 간단하다. 일반적으로 일반변수는 함수가 끝날 때 사라진다. state를 업데이트 해놓았다고 쳐도 함수가 다시 실행될 때마다 state가 다시 초기값으로 돌아가게 될 것 이다.
- 이런 이유로 state 값을 저장하기 위해 hook의 `useState`를 활용한다. `useState`를 통해 함수형 컴포넌트에서도 state를 사용할 수 있다.
- `useState`는 다음 리렌더링시 배열의 첫번째 요소로 갱신된 최신 state를 반환한다.
- 보통 `useState`를 통해 state를 만들어줄 때 const를 통해 선언해준다. 그런데 state는 변경이 되는 값이다. const로 선언된 변수는 변경이 되면 안되는데 어떻게 state를 변경해주는 것일까? 사실 `setState`를 통해 state를 변경하는 것이 아니다. `useState`안에서 '접근 할 수 있는 변수 값'을 변경한다. `useState` 내부에서 접근할 수 있는 변수의 값을 업데이트 해주고 이를 배열에 담아 반환해준다. 함수형 컴포넌트가 실행될 때 state값을 사실상 재할당이 되는 것이다.

<br>
<br>

## 참고

- 내 테코톡
- [공식문서 - state 올바르게 사용하기](https://ko.reactjs.org/docs/state-and-lifecycle.html#using-state-correctly)
